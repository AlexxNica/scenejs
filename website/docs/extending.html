<html>

<head>
    <title>SceneJS | OpenGL Scene Graph for Javascript</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta http-equiv="Content-Style-Type" content="text/css"/>

    <script class="javascript" src="../js/sh/sh_main.min.js"></script>
    <script class="javascript" src="../js/sh/sh_javascript.js"></script>

    <link href="../css/sh_style.css" rel="stylesheet" type="text/css"/>

    <link href="../css/style.css" rel="stylesheet" type="text/css"/>
    <link href="../css/layout.css" rel="stylesheet" type="text/css"/>


</head>

<body id="about" onload="sh_highlightDocument();">

<div id="main">

    <div id="header">
        <a href="../index.html"><img src="../images/scenejs_small.png" id="logo" alt=""/></a>
        <ul id="menu">
        <li><a href="../downloads/downloads.html"><span><span>Download</span></span></a></li>
            <li id="menu-act"><a href="introduction.html"><span><span>Documentation</span></span></a></li>
            <li><a href="http://github.com/xeolabs/scenejs/issues"><span><span>Issues</span></span></a></li>
            <li><a href="http://scenejs.bbster.net/"><span><span>Forum</span></span></a></li>
            <li><a href="http://github.com/xeolabs/scenejs"><span><span>Sourcecode</span></span></a></li>
        </ul>
        <div id="headerContent">
            <div id="headerContentContainer">
                <a href="introduction.html">Introduction</a>&nbsp;|&nbsp;<a href="graphapi.html">Core Graph API</a>&nbsp;|&nbsp;Extending SceneJs
            </div>
        </div>
    </div>

    <div id="content">
        <div class="row-1">
            <div class="wrapper">
                <h1>Extending SceneJS</h1>

                <p><span>One of the coolest things about SceneJS is that you can extend it easily; you can extend its API
                    by defining new scene node types, and when a new type of HTML Canvas appears, you can add
                    support for it.</span></p>

                <p><span>The SceneJS architecture is split into two layers: the <b>front-end</b>, which contains scene graph node
                types, and the <b>back-end</b>, a framework containing plugins that mediate between the nodes and the supported canvases.</span>
                </p>

                <p><span>There are actually two kinds of plugin: <b>CanvasBackends</b>, which acquire contexts on supported
                   canvases in the DOM, and <b>NodeBackends</b>, which each provide their corresponding scene node type
                    with a facade through which they can drive a supported type of canvas. The <b>SceneJS.Backend</b> singleton ties
                    all this together: for each supported canvas, SceneJS.Backend will have a CanvasBackend and a set of NodeBackends,
                    one for each scene node type that supports the canvas.</span></p>
                <img src="../images/backend-classes.png"/>

                <p><span>When a <a href="../intro.html#canvas">Canvas</a> scene node is pre-visited during <a
                        href="../graph.html#struct">graph traversal</a> , it calls SceneJS.Backend.acquireCanvas to
                    activate its canvas. Recall that a Canvas node is configured with
                    a canvas ID. Then as sub-Nodes are visited, they can each call SceneJS.Backend.getBackend to get an appropriate
                    NodeBackend through which they can interact with the active canvas. When the Canvas is post-visited,
                    it calls SceneJS.Backend.releaseCanvas to deactivate the canvas. Internally, SceneJS.Backend automatically
                    employs the appropriate plugins to support these methods. We'll look at this in more detail below. </span>
                </p>

                <br/>

                <p><span>In this page, I'm going to take you through an extension scenario: a new type of canvas element has arrived in browsers
                and you want to start making some scene node classes to drive it. This also covers what you would do to add support
                for a new canvas to existing node classes, and what you would do to define a new node type for
                a canvas that is already supported for other nodes.</span></p>

                <p><span>We're going to add three elements to SceneJS:</span></p>  <br/>
                <ul class="featurelist">
                    <li class="featurelist"><a href="extending.html#canvas-backend">CanvasBackend Plugin</a>
                        - locates the supported canvas element and acquires a context on it
                    </li>
                    <li class="featurelist"><a href="extending.html#node-backend">NodeBackend Plugin</a> - provides
                        a
                        facade of functions to the node through which it can drive the canvas
                    </li>
                    <li class="featurelist"><a href="extending.html#node-class">Front-end Scene Node Class</a> - extends the basic
                        Node
                        class to do stuff
                        to the canvas on pre- and post-visit.
                    </li>
                </ul>
                <br/>

                <p><span>Then we'll look at <a href="extending.html#framework-sequence">sequence of interactions</a> between all these classes.</span>
                </p>
                <br/>
                 <br/>

                <a name="canvas-backend"></a>

                <h2>CanvasBackend Plugin</h2>

                <p><span>Here's that canvas backend plugin. I'll let the comments do the talking for all the source files - you can
                also see when its methods are called in the <a href="extending.html#framework-sequence">sequence of interactions</a> diagram below.
                Note how we just plug an anonymous instance of it into SceneJs.Backend. There are no actual baseclasse
                implementations for any of these plugins - they are more like names of contracts for them to honour.
                </span></p>
                <br/>
                <script src="http://gist.github.com/207184.js"></script>

                <br/>

                <a name="node-backend"></a>

                <h2>NodeBackend Plugin</h2>

                <p><span>And here's that node backend plugin we were talking about:</span></p>
                <br/>
                <script src="http://gist.github.com/207191.js"></script>

                <br/>

                <a name="node-class"></a>

                <h2>Front-end Scene Node Class</h2>

                <p><span>And our last class, our new scene node type on the front-end:</span></p>
                <br/>
                <script src="http://gist.github.com/207287.js"></script>

                <br/>

                <a name="framework-sequence"></a>

                <h2>Sequence of Interactions within the Framework</h2>

                <p><span>The sequence diagram below shows how the classes work together. Maybe it's just a little bit more than
                    you really wanted to know on your one-hour lunchbreak, but bear with me for a minute and I'll step you through it. As the Graph is
                traversed, it pre-visits a Device which has been configured to acquire a canvas with a given ID for its
                sub-nodes to render to, which happens to be an "awesome-new-canvas-0.1" canvas element in the DOM.
                The Device tries to acquire the canvas from the SceneJS.Backend, which finds the canvas and then polls
                    each installed CanvasBackend for a configuration (wrapping a context) on it. The first CanvasBackend
                    fails to provide a configuration because it does not support an "awesome-new-canvas-0.1" canvas, but
                    the second one (that's the one we just plugged in) does, and thus succeeds. The SceneJS.Backend then
                    acquires the canvas though our CanvasBackend, passing it the configuration for it to set up whatever resources it needs
                    against the canvas.</span></p>

                <p><span>Next, traversal descends into the Device's sub-nodes. When our new node (MyNewNode, the one we just created) is
                    pre-visited, it requests the "my-node-type" NodeBackend (the one we just plugged in) from the SceneJS.Backend.
                    The SceneJS.Backend locates the NodeBackend, injects the configuration and returns it. The node then
                    calls the NodeBackend's doSomethingToCanvas method.</span></p>

                <p><span>When the Device is post-rendered, it signals the SceneJS.Backend to release the canvas. The SceneJS.Backend calls
                    release on the CanvasBackend, which then has a chance to release any resources it needs to.</span>
                </p>
                <br/><br/>
                <img src="../images/backend-classes-sequence.png"/>

            </div>
        </div>
        <div id="footer">
            <p>&copy; 2009, <a href="http://www.xeolabs.com">XeoLabs</a></p>

        </div>

    </div>

</div>

<!--
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10689958-1");
pageTracker._trackPageview();
} catch(err) {}
</script>
-->
</body>

</html>
