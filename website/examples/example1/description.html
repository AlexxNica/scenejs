<h1>Example 1 - A Basic Scene Graph</h1>

<p><span>Our first example renders the venerable OpenGL teapot. See how it is composed of functions; these
    are called in depth-first
    order, each setting some OpenGL state on entry, then un-setting it again on exit. In this scene,
    a <b>canvas</b> activates a Canvas element, a <b>shader</b>
activates some <a href="http://en.wikipedia.org/wiki/GLSL">GLSL</a> scripts, and the rest of the nodes set various matrices, vectors and geometry variables
within the scripts (except for <b>viewport</b> which calls a fixed OpenGL function).</span></p>

<p><span>Note that the function calls generally take the form <b class="code">node({<i>configs</i>},
    <i>child</i>,<i>child</i>...)</b>.
Node configurations only specify properties that override defaults, such as non-zero vector components.</span>
</p>

<p><span>Take a closer look at that rotate node. See how it takes a function which creates its configuration object?
    You can do that when you want a node's configuration to be evaluated dynamically at traversal-time. The function
    takes a scope, which is SceneJS's mechanism for passing variables down into a scene graph. Using the angle variable
    on the scope, the function creates a configuration that specifies a rotation about the X-axis. See also how we inject that
    angle variable when we render the scene.</span></p>