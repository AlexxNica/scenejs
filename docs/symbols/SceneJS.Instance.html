<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		<meta name="generator" content="JsDoc Toolkit" />
		
		<title>JsDoc Reference - SceneJS.Instance</title>

		<style type="text/css">
			/* default.css */
body
{
	font: 12px "Lucida Grande", Tahoma, Arial, Helvetica, sans-serif;
	width: 800px;
}

.header
{
	clear: both;
	background-color: #ccc;
	padding: 8px;
}

h1
{
	font-size: 150%;
	font-weight: bold;
	padding: 0;
	margin: 1em 0 0 .3em;
}

hr
{
	border: none 0;
	border-top: 1px solid #7F8FB1;
	height: 1px;
}

pre.code
{
	display: block;
	padding: 8px;
	border: 1px dashed #ccc;
}

#index
{
	margin-top: 24px;
	float: left;
	width: 160px;
	position: absolute;
	left: 8px;
	background-color: #F3F3F3;
	padding: 8px;
}

#content
{
	margin-left: 190px;
	width: 600px;
}

.classList
{
	list-style-type: none;
	padding: 0;
	margin: 0 0 0 8px;
	font-family: arial, sans-serif;
	font-size: 1em;
	overflow: auto;
}

.classList li
{
	padding: 0;
	margin: 0 0 8px 0;
}

.summaryTable { width: 100%; }

h1.classTitle
{
	font-size:170%;
	line-height:130%;
}

h2 { font-size: 110%; }
caption, div.sectionTitle
{
	background-color: #7F8FB1;
	color: #fff;
	font-size:130%;
	text-align: left;
	padding: 2px 6px 2px 6px;
	border: 1px #7F8FB1 solid;
}

div.sectionTitle { margin-bottom: 8px; }
.summaryTable thead { display: none; }

.summaryTable td
{
	vertical-align: top;
	padding: 4px;
	border-bottom: 1px #7F8FB1 solid;
	border-right: 1px #7F8FB1 solid;
}

/*col#summaryAttributes {}*/
.summaryTable td.attributes
{
	border-left: 1px #7F8FB1 solid;
	width: 140px;
	text-align: right;
}

td.attributes, .fixedFont
{
	line-height: 15px;
	color: #002EBE;
	font-family: "Courier New",Courier,monospace;
	font-size: 13px;
}

.summaryTable td.nameDescription
{
	text-align: left;
	font-size: 13px;
	line-height: 15px;
}

.summaryTable td.nameDescription, .description
{
	line-height: 15px;
	padding: 4px;
	padding-left: 4px;
}

.summaryTable { margin-bottom: 8px; }

ul.inheritsList
{
	list-style: square;
	margin-left: 20px;
	padding-left: 0;
}

.detailList {
	margin-left: 20px; 
	line-height: 15px;
}
.detailList dt { margin-left: 20px; }

.detailList .heading
{
	font-weight: bold;
	padding-bottom: 6px;
	margin-left: 0;
}

.light, td.attributes, .light a:link, .light a:visited
{
	color: #777;
	font-style: italic;
}

.fineprint
{
	text-align: right;
	font-size: 10px;
}
		</style>
	</head>

	<body>
<!-- ============================== header ================================= -->	
		<!-- begin static/header.html -->
		<div id="header">
</div>
		<!-- end static/header.html -->

<!-- ============================== classes index ============================ -->
		<div id="index">
			<!-- begin publish.classesIndex -->
			<div align="center"><a href="../index.html">Class Index</a>
| <a href="../files.html">File Index</a></div>
<hr />
<h2>Classes</h2>
<ul class="classList">
	
	<li><i><a href="../symbols/_global_.html">_global_</a></i></li>
	
	<li><a href="../symbols/SceneJS.html">SceneJS</a></li>
	
	<li><a href="../symbols/SceneJS.BoundingBox.html">SceneJS.BoundingBox</a></li>
	
	<li><a href="../symbols/SceneJS.CanvasNotFoundException.html">SceneJS.CanvasNotFoundException</a></li>
	
	<li><a href="../symbols/SceneJS.ColladaRootNotFoundException.html">SceneJS.ColladaRootNotFoundException</a></li>
	
	<li><a href="../symbols/SceneJS.ColladaRootRequiredException.html">SceneJS.ColladaRootRequiredException</a></li>
	
	<li><a href="../symbols/SceneJS.Data.html">SceneJS.Data</a></li>
	
	<li><a href="../symbols/SceneJS.DataExpectedException.html">SceneJS.DataExpectedException</a></li>
	
	<li><a href="../symbols/SceneJS.DocumentElementNotFoundException.html">SceneJS.DocumentElementNotFoundException</a></li>
	
	<li><a href="../symbols/SceneJS.EmptyResponseException.html">SceneJS.EmptyResponseException</a></li>
	
	<li><a href="../symbols/SceneJS.Exception.html">SceneJS.Exception</a></li>
	
	<li><a href="../symbols/SceneJS.Fog.html">SceneJS.Fog</a></li>
	
	<li><a href="../symbols/SceneJS.Generator.html">SceneJS.Generator</a></li>
	
	<li><a href="../symbols/SceneJS.Geometry.html">SceneJS.Geometry</a></li>
	
	<li><a href="../symbols/SceneJS.HttpException.html">SceneJS.HttpException</a></li>
	
	<li><a href="../symbols/SceneJS.Instance.html">SceneJS.Instance</a></li>
	
	<li><a href="../symbols/SceneJS.InternalException.html">SceneJS.InternalException</a></li>
	
	<li><a href="../symbols/SceneJS.Interpolator.html">SceneJS.Interpolator</a></li>
	
	<li><a href="../symbols/SceneJS.InvalidNodeConfigException.html">SceneJS.InvalidNodeConfigException</a></li>
	
	<li><a href="../symbols/SceneJS.InvalidSceneGraphException.html">SceneJS.InvalidSceneGraphException</a></li>
	
	<li><a href="../symbols/SceneJS.Inverse.html">SceneJS.Inverse</a></li>
	
	<li><a href="../symbols/SceneJS.Lights.html">SceneJS.Lights</a></li>
	
	<li><a href="../symbols/SceneJS.LightSource.html">SceneJS.LightSource</a></li>
	
	<li><a href="../symbols/SceneJS.LoadTimeoutException.html">SceneJS.LoadTimeoutException</a></li>
	
	<li><a href="../symbols/SceneJS.Locality.html">SceneJS.Locality</a></li>
	
	<li><a href="../symbols/SceneJS.Logging.html">SceneJS.Logging</a></li>
	
	<li><a href="../symbols/SceneJS.LoggingToPage.html">SceneJS.LoggingToPage</a></li>
	
	<li><a href="../symbols/SceneJS.LookAt.html">SceneJS.LookAt</a></li>
	
	<li><a href="../symbols/SceneJS.Material.html">SceneJS.Material</a></li>
	
	<li><a href="../symbols/SceneJS.Matrix.html">SceneJS.Matrix</a></li>
	
	<li><a href="../symbols/SceneJS.Name.html">SceneJS.Name</a></li>
	
	<li><a href="../symbols/SceneJS.Node.html">SceneJS.Node</a></li>
	
	<li><a href="../symbols/SceneJS.NodeConfigExpectedException.html">SceneJS.NodeConfigExpectedException</a></li>
	
	<li><a href="../symbols/SceneJS.objects.Cube.html">SceneJS.objects.Cube</a></li>
	
	<li><a href="../symbols/SceneJS.objects.Sphere.html">SceneJS.objects.Sphere</a></li>
	
	<li><a href="../symbols/SceneJS.objects.Teapot.html">SceneJS.objects.Teapot</a></li>
	
	<li><a href="../symbols/SceneJS.OutOfVRAMException.html">SceneJS.OutOfVRAMException</a></li>
	
	<li><a href="../symbols/SceneJS.ParseException.html">SceneJS.ParseException</a></li>
	
	<li><a href="../symbols/SceneJS.ProxyEmptyResponseException.html">SceneJS.ProxyEmptyResponseException</a></li>
	
	<li><a href="../symbols/SceneJS.ProxyErrorResponseException.html">SceneJS.ProxyErrorResponseException</a></li>
	
	<li><a href="../symbols/SceneJS.ProxyNotSpecifiedException.html">SceneJS.ProxyNotSpecifiedException</a></li>
	
	<li><a href="../symbols/SceneJS.Quaternion.html">SceneJS.Quaternion</a></li>
	
	<li><a href="../symbols/SceneJS.Renderer.html">SceneJS.Renderer</a></li>
	
	<li><a href="../symbols/SceneJS.Rotate.html">SceneJS.Rotate</a></li>
	
	<li><a href="../symbols/SceneJS.Scale.html">SceneJS.Scale</a></li>
	
	<li><a href="../symbols/SceneJS.Scene.html">SceneJS.Scene</a></li>
	
	<li><a href="../symbols/SceneJS.Selector.html">SceneJS.Selector</a></li>
	
	<li><a href="../symbols/SceneJS.Stationary.html">SceneJS.Stationary</a></li>
	
	<li><a href="../symbols/SceneJS.Symbol.html">SceneJS.Symbol</a></li>
	
	<li><a href="../symbols/SceneJS.SymbolNotFoundException.html">SceneJS.SymbolNotFoundException</a></li>
	
	<li><a href="../symbols/SceneJS.Text.html">SceneJS.Text</a></li>
	
	<li><a href="../symbols/SceneJS.Texture.html">SceneJS.Texture</a></li>
	
	<li><a href="../symbols/SceneJS.TextureLayer.html">SceneJS.TextureLayer</a></li>
	
	<li><a href="../symbols/SceneJS.Translate.html">SceneJS.Translate</a></li>
	
	<li><a href="../symbols/SceneJS.WebGLNotSupportedException.html">SceneJS.WebGLNotSupportedException</a></li>
	
	<li><a href="../symbols/SceneJS.WebGLUnsupportedNodeConfigException.html">SceneJS.WebGLUnsupportedNodeConfigException</a></li>
	
	<li><a href="../symbols/SceneJS.WithConfigs.html">SceneJS.WithConfigs</a></li>
	
	<li><a href="../symbols/SceneJS.WithData.html">SceneJS.WithData</a></li>
	
</ul>
<hr />
			<!-- end publish.classesIndex -->
		</div>
		
		<div id="content">
<!-- ============================== class title ============================ -->
			<h1 class="classTitle">
				
				Class SceneJS.Instance
			</h1>

<!-- ============================== class summary ========================== -->			
			<p class="description">
				
				<br />Extends
					<a href="../symbols/SceneJS.Node.html">SceneJS.Node</a>.<br />
				
			
				Causes an instance of a resource to be inserted into a scene graph.

<p>The resource can come from the entire contents of a model file, a selected element in a model file, or from a
Symbol that has been previously rendered in the scene graph. For each of these cases, the Instance's uri parameter
will take a different form, as shown in these examples.</p>

<p>To instance an entire model from a file, specify an absolute URI to the file with no fragment part. Here we're
instancing the default scene defined in a COLLADA file:</p>
<pre><code>
new SceneJS.Instance({
   uri: "http://foo.com/models/airplane.dae"
})
</code></pre>
<p>For some file formats, SceneJS allows you to instance a selected a resource (or "asset") from within them. Here
we're instancing a selected scene within a COLLADA file:</p>
<pre><code>
new SceneJS.Instance({
    uri: "http://foo.com/models/suburbia.dae#house_scene"
})
</code></pre>
<p>If we know that file is really big and will take longer than the default of 180 seconds to arrive, we can configure
our own timeout, in this case a generous six minutes:</p>
 <pre><code>
new SceneJS.Instance({
    uri: "http://foo.com/models/suburbia.dae#house_scene",
    loadTimeoutSecs: 360
})
</code></pre>
<p>When a Symbol has been rendered prior to the Instance during scene traversal, then the Instance may instantiate it
with a URI that contains only the fragment part, which will walk the SIDs (sub-identifiers) of previously rendered
nodes to resolve the Symbol. Here's the most trivial case - see how the fragment URI of the instance maps to the
Symbol's SID.<p>
<pre><code>
new SceneJS.Symbol({ sid: "myBox" },
   new SceneJS.objects.Cube()
),

new SceneJS.Instance( { uri: "myBox" })
</code></pre>
<p>Another case, in which an Instance resolves a Symbol that is within a namespace defined by the SID of a parent
node:</p>
<pre><code>
new SceneJS.Node({ sid: "mySymbols" },
    new SceneJS.Symbol({ sid: "myBox" },
        new SceneJS.objects.Cube()
    )
),

new SceneJS.Instance( { uri: "mySymbols/myBox" })
</code></pre>
<p>Think of these nested SIDs as directories, where the URI fragment part works works the same way as a directory
path. An absolute fragment path begins with a '/' - in the following example, if the node with the "moreSymbols" SID
is defined at the top level, we may then reference it with an absolute path:</p>
<pre><code>
new SceneJS.Node({ sid: "moreSymbols" },
    new SceneJS.Symbol({ sid: "myOtherBox" },
        new SceneJS.objects.Cube()
    )
),

new SceneJS.Instance( { uri: "/moreSymbols/myOtherBox" })
</code></pre>

<p>For some model file formats, you can use an absolute URI with a fragment to instantiate hierarchically-organised
resources within them. When SceneJS loads a COLLADA model, for example, it will create Symbol nodes within SID
namespaces (as shown above) that will allow you to instantiate selected scenes. You can even instantiate a
selected COLLADA scene via one of its cameras: </p>

</code></pre>
new SceneJS.Instance( {
    uri: "http://foo.com/models/suburbia.dae#house_scene/camera1"
});

<h2>File Loading States</h2>
<p>When instancing content from a file, an Instance node must first perform an HTTP GET to load it. That is, unless
some other Instance has already loaded that file, in which case SceneJS will have internally cached a subgraph
parsed from that file.</p>

<p>When instancing content from a file, an Instance node must first perform an HTTP GET to load it. That is, unless
some other Instance has already loaded that file, in which case SceneJS will have internally cached a subgraph
parsed from that file.</p>

<p>Each Instance that must load a file will transition through six different states as its request is processed,
which may be queried through the Instance's <a href="#getState">#getState</a> method:</p>
<ul><li><a href="#STATE_INITIAL">#STATE_INITIAL</a> in which it is about to make an asynchronous request for the content.</li>
<li><a href="#STATE_LOADING">#STATE_LOADING</a> in which it has made the request and is awaiting the response, which it will receive
at any time, either within a scene render or between scene renders. In this state it has nothing to render
and will pass scene traversal on to its next sibling.</li>
<li><a href="#STATE_LOADED">#STATE_LOADED</a> in which it has successfully received its content and parsed it into a subgraph.
From here the node will transition to <a href="#STATE_RENDERED">#STATE_RENDERED</a> as soon as the subgraph has been rendered
and traversal has arrived back at this node on the way back up the graph. It may instead transition back
to <a href="#STATE_INITIAL">#STATE_INITIAL</a> as soon as it has not been rendered in a while and has then had its subgraph destroyed
by SceneJS to reclaim memory.</li>
<li><a href="#STATE_RENDERED">#STATE_RENDERED</a> in which it has successfully received its content, parsed it into a subgraph, and been rendered
at least once. From here the node will transition back to <a href="#STATE_INITIAL">#STATE_INITIAL</a> as soon as it has not been rendered in
a while and has then had its subgraph destroyed by SceneJS to reclaim memory.</li>
<li><a href="#STATE_FREED">#STATE_FREED</a> in which it has been dormant too long and SceneJS has reclaimed memory by destroying
the subgraph. When next rendered, it will then repeat its load request and transition
to <a href="#STATE_LOADING">#STATE_LOADING</a>.</li>
<li><a href="#STATE_ERROR">#STATE_ERROR</a> if SceneJS has permanently inactivated the node after load failed</li></ul>
<p>Note that when instantiating from a file that has been previously loaded by another Instance, it will transition
directly to <a href="#STATE_RENDERED">#STATE_RENDERED</a>.<p>

<p><b>Loading Cross-Domain</b></p>
<p>When SceneJS is configured with a JSONP strategy via <a href="../symbols/SceneJS.html#.setJSONPStrategy">SceneJS.setJSONPStrategy</a>, you can perform the
load cross-domain. Otherwise, the URL of the content must be at the same domain as the scene definition's JavaScript file
in order to not violate the browser' same-domain security policy.

<p><b>Live Examples</b></p>
<li><a target = "other" href="http://bit.ly/scenejs-asset-load">Example 1</a></li>
</ul>
				
				
					<br /><i>Defined in: </i> <a href="../symbols/src/_home_lindsay_xeolabs_projects_scenejs_src_scenejs_instancing_instance.js.html">instance.js</a>.
				
			</p>

<!-- ============================== constructor summary ==================== -->			
			
			<table class="summaryTable" cellspacing="0" summary="A summary of the constructor documented in the class SceneJS.Instance.">
				<caption>Class Summary</caption>
				<thead>
					<tr>
						<th scope="col">Constructor Attributes</th>
						<th scope="col">Constructor Name and Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="attributes">&nbsp;</td>
						<td class="nameDescription" >
							<div class="fixedFont">
								<b><a href="../symbols/SceneJS.Instance.html#constructor">SceneJS.Instance</a></b>(cfg, fn, childNodes)
							</div>
							<div class="description"></div>
						</td>
					</tr>
				</tbody>
			</table>
			

<!-- ============================== properties summary ===================== -->
			
				
				
				<table class="summaryTable" cellspacing="0" summary="A summary of the fields documented in the class SceneJS.Instance.">
					<caption>Field Summary</caption>
					<thead>
						<tr>
							<th scope="col">Field Attributes</th>
							<th scope="col">Field Name and Description</th>
						</tr>
					</thead>
					<tbody>
					
						<tr>
							<td class="attributes">&lt;static&gt; &nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont">
								SceneJS.Instance.<b><a href="../symbols/SceneJS.Instance.html#.STATE_ERROR">STATE_ERROR</a></b>
								</div>
								<div class="description">State in which load has failed.</div>
							</td>
						</tr>
					
						<tr>
							<td class="attributes">&lt;static&gt; &nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont">
								SceneJS.Instance.<b><a href="../symbols/SceneJS.Instance.html#.STATE_FREED">STATE_FREED</a></b>
								</div>
								<div class="description">State in which load is pending after node has had its subgraph destroyed by SceneJS to reclaim memory after
not having been rendered for some time (Eg.</div>
							</td>
						</tr>
					
						<tr>
							<td class="attributes">&lt;static&gt; &nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont">
								SceneJS.Instance.<b><a href="../symbols/SceneJS.Instance.html#.STATE_INITIAL">STATE_INITIAL</a></b>
								</div>
								<div class="description">State in which load is pending because node has not been rendered yet and hence has
not made its load request yet.</div>
							</td>
						</tr>
					
						<tr>
							<td class="attributes">&lt;static&gt; &nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont">
								SceneJS.Instance.<b><a href="../symbols/SceneJS.Instance.html#.STATE_LOADED">STATE_LOADED</a></b>
								</div>
								<div class="description">State in which node has successfully received its content and parsed it into a subgraph.</div>
							</td>
						</tr>
					
						<tr>
							<td class="attributes">&lt;static&gt; &nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont">
								SceneJS.Instance.<b><a href="../symbols/SceneJS.Instance.html#.STATE_LOADING">STATE_LOADING</a></b>
								</div>
								<div class="description">State in which node is awaiting a response to its load request.</div>
							</td>
						</tr>
					
						<tr>
							<td class="attributes">&lt;static&gt; &nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont">
								SceneJS.Instance.<b><a href="../symbols/SceneJS.Instance.html#.STATE_RENDERED">STATE_RENDERED</a></b>
								</div>
								<div class="description">State in which node has successfully received its content, parsed it into a subgraph, and been rendered
at least once.</div>
							</td>
						</tr>
					
					</tbody>
				</table>
				
				
				
				<dl class="inheritsList">
				
				</dl>
				
			

<!-- ============================== methods summary ======================== -->
			
				
				
				<table class="summaryTable" cellspacing="0" summary="A summary of the methods documented in the class SceneJS.Instance.">
					<caption>Method Summary</caption>
					<thead>
						<tr>
							<th scope="col">Method Attributes</th>
							<th scope="col">Method Name and Description</th>
						</tr>
					</thead>
					<tbody>
					
						<tr>
							<td class="attributes">&nbsp;</td>
							<td class="nameDescription">
								<div class="fixedFont"><b><a href="../symbols/SceneJS.Instance.html#getState">getState</a></b>()
								</div>
								<div class="description">Returns the node's current state.</div>
							</td>
						</tr>
					
					</tbody>
				</table>
				
				
				
				<dl class="inheritsList">
				<dt>Methods borrowed from class <a href="../symbols/SceneJS.Node.html">SceneJS.Node</a>: </dt><dd><a href="../symbols/SceneJS.Node.html#addListener">addListener</a>, <a href="../symbols/SceneJS.Node.html#addNode">addNode</a>, <a href="../symbols/SceneJS.Node.html#findNodesByType">findNodesByType</a>, <a href="../symbols/SceneJS.Node.html#getInfo">getInfo</a>, <a href="../symbols/SceneJS.Node.html#getNodeAt">getNodeAt</a>, <a href="../symbols/SceneJS.Node.html#getNodes">getNodes</a>, <a href="../symbols/SceneJS.Node.html#getNumNodes">getNumNodes</a>, <a href="../symbols/SceneJS.Node.html#getParent">getParent</a>, <a href="../symbols/SceneJS.Node.html#getSID">getSID</a>, <a href="../symbols/SceneJS.Node.html#getType">getType</a>, <a href="../symbols/SceneJS.Node.html#insertNode">insertNode</a>, <a href="../symbols/SceneJS.Node.html#removeListener">removeListener</a>, <a href="../symbols/SceneJS.Node.html#removeNodeAt">removeNodeAt</a>, <a href="../symbols/SceneJS.Node.html#setInfo">setInfo</a></dd>
				</dl>
				
			
<!-- ============================== events summary ======================== -->
			

<!-- ============================== constructor details ==================== -->		
			
			<div class="details"><a name="constructor"> </a>
				<div class="sectionTitle">
					Class Detail
				</div>
				
				<div class="fixedFont">
						<b>SceneJS.Instance</b>(cfg, fn, childNodes)
				</div>
				
				<div class="description">
					
					
				</div>
				
				
				
				
					
						<dl class="detailList">
						<dt class="heading">Parameters:</dt>
						
							<dt>
								<span class="light fixedFont">{Object}</span>  <b>cfg</b>
								<i>Optional</i>
							</dt>
								<dd>Static configuration object</dd>
						
							<dt>
								<span class="light fixedFont">{String}</span>  <b>cfg.uri</b>
								
							</dt>
								<dd>URI of file to load</dd>
						
							<dt>
								<span class="light fixedFont">{int}</span>  <b>cfg.timeoutSecs</b>
								<i>Optional</i>
							</dt>
								<dd>Timeout - falls back on any loadTimoutSecs that was configured on the <a href="../symbols/SceneJS.Scene.html">SceneJS.Scene</a>
at the root of the scene graph, or the default 180 seconds if none configured there</dd>
						
							<dt>
								<span class="light fixedFont">{function(SceneJS.Data):Object}</span>  <b>fn</b>
								<i>Optional</i>
							</dt>
								<dd>Dynamic configuration function</dd>
						
							<dt>
								<span class="light fixedFont">{...SceneJS.Node}</span>  <b>childNodes</b>
								<i>Optional</i>
							</dt>
								<dd>Child nodes</dd>
						
						</dl>
					
					
					
					
					
					
					

			</div>
			

<!-- ============================== field details ========================== -->		
			
				<div class="sectionTitle">
					Field Detail
				</div>
				
					<a name=".STATE_ERROR"> </a>
					<div class="fixedFont">&lt;static&gt; 
					
					
					<span class="light">SceneJS.Instance.</span><b>STATE_ERROR</b>
					
					</div>
					<div class="description">
						State in which load has failed. This can be either due to HTTP error (eg. HTTP 404) or
failure to parse the response. The node will now be permanently inactive and stuck in this state.
						
						
					</div>
					
					

						
						
						
						

					<hr />
				
					<a name=".STATE_FREED"> </a>
					<div class="fixedFont">&lt;static&gt; 
					
					
					<span class="light">SceneJS.Instance.</span><b>STATE_FREED</b>
					
					</div>
					<div class="description">
						State in which load is pending after node has had its subgraph destroyed by SceneJS to reclaim memory after
not having been rendered for some time (Eg. is within a SceneJS.Boundary that has
not intersected the view frustum for a while, or perhaps within a <a href="../symbols/SceneJS.Selector.html">SceneJS.Selector</a> that has
not selected it lately). When next rendered, it will then repeat its load request and transition
to <a href="#STATE_LOADING">#STATE_LOADING</a>.
						
						
					</div>
					
					

						
						
						
						

					<hr />
				
					<a name=".STATE_INITIAL"> </a>
					<div class="fixedFont">&lt;static&gt; 
					
					
					<span class="light">SceneJS.Instance.</span><b>STATE_INITIAL</b>
					
					</div>
					<div class="description">
						State in which load is pending because node has not been rendered yet and hence has
not made its load request yet. When next rendered, it will then make its load request
and transition to <a href="#STATE_LOADING">#STATE_LOADING</a>.
						
						
					</div>
					
					

						
						
						
						

					<hr />
				
					<a name=".STATE_LOADED"> </a>
					<div class="fixedFont">&lt;static&gt; 
					
					
					<span class="light">SceneJS.Instance.</span><b>STATE_LOADED</b>
					
					</div>
					<div class="description">
						State in which node has successfully received its content and parsed it into a subgraph.
From here the node will transition to <a href="#STATE_RENDERED">#STATE_RENDERED</a> as soon as the subgraph has been rendered
and traversal has arrived back at this node on the way back up the graph.
						
						
					</div>
					
					

						
						
						
						

					<hr />
				
					<a name=".STATE_LOADING"> </a>
					<div class="fixedFont">&lt;static&gt; 
					
					
					<span class="light">SceneJS.Instance.</span><b>STATE_LOADING</b>
					
					</div>
					<div class="description">
						State in which node is awaiting a response to its load request. When the response arrives (asyncronously, ie.
either during or between scene renders), the node will then transition to  either <a href="#STATE_LOADED">#STATE_LOADED</a>
or <a href="#STATE_ERROR">#STATE_ERROR</a>, depending on whether or not it successfully parses the response. If the
response does not arrive or parse within the timeout period (180 seconds by default, unless configured) it will
transition to STATE_ERROR.
						
						
					</div>
					
					

						
						
						
						

					<hr />
				
					<a name=".STATE_RENDERED"> </a>
					<div class="fixedFont">&lt;static&gt; 
					
					
					<span class="light">SceneJS.Instance.</span><b>STATE_RENDERED</b>
					
					</div>
					<div class="description">
						State in which node has successfully received its content, parsed it into a subgraph, and been rendered
at least once. From here the node will transition back to <a href="#STATE_INITIAL">#STATE_INITIAL</a> as soon as it has not been rendered in
a while and has then had its subgraph destroyed by SceneJS to reclaim memory.
						
						
					</div>
					
					

						
						
						
						

					
				
			

<!-- ============================== method details ========================= -->		
			
				<div class="sectionTitle">
					Method Detail
				</div>
				
					<a name="getState"> </a>
					<div class="fixedFont">
					
					<span class="light">{int}</span>
					<b>getState</b>()
					
					</div>
					<div class="description">
						Returns the node's current state. Possible states are <a href="#STATE_INITIAL">#STATE_INITIAL</a>, <a href="#STATE_LOADING">#STATE_LOADING</a>,
<a href="#STATE_LOADED">#STATE_LOADED</a>, <a href="#STATE_FREED">#STATE_FREED</a> and <a href="#STATE_ERROR">#STATE_ERROR</a>.
						
						
					</div>
					
					
					
						
						
						
						
						
							<dl class="detailList">
							<dt class="heading">Returns:</dt>
							
								<dd><span class="light fixedFont">{int}</span> The state</dd>
							
							</dl>
						
						
						

					
				
			
			
<!-- ============================== event details ========================= -->		
			
			
			<hr />
		</div>

		
<!-- ============================== footer ================================= -->
		<div class="fineprint" style="clear:both">
			
			Documentation generated by <a href="http://code.google.com/p/jsdoc-toolkit/" target="_blank">JsDoc Toolkit</a> 2.3.2 on Fri Jun 18 2010 22:54:21 GMT+1200 (NZST)
		</div>
	</body>
</html>
