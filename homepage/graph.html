<html>

<head>
    <title>SceneJS | OpenGL Scene Graph for Javascript</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta http-equiv="Content-Style-Type" content="text/css"/>

    <script class="javascript" src="js/sh_main.min.js"></script>
    <script class="javascript" src="js/sh_javascript.js"></script>


    <link href="css/sh_style.css" rel="stylesheet" type="text/css"/>

    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="css/layout.css" rel="stylesheet" type="text/css"/>


</head>

<body id="about" onload="sh_highlightDocument();">

<div id="main">

<!-- header -->
<div id="header">

    <a href="index.html"><img src="images/scenejs_small.png" id="logo" alt=""/></a>


    <ul id="menu">
        <li><a href="http://github.com/xeolabs/scenejs/downloads"><span><span>Download</span></span></a></li>
        <li id="menu-act"><a href="example1.html"><span><span>More Info</span></span></a></li>
        <li><a href="http://github.com/xeolabs/scenejs/issues"><span><span>Issues</span></span></a></li>
        <li><a href=""><span><span>Forum</span></span></a></li>
        <li><a href="http://github.com/xeolabs/scenejs"><span><span>Sourcecode</span></span></a></li>
    </ul>


    <div id="headerContent">
        <h1>A Quick Taste of SceneJS</h1>

        <div id="headerContentContainer">
            <p><span><b>SceneJS</b> is an open source Javascript framework from <a
                    href="http://www.xeolabs.com">XeoLabs</a>,
                        that layers an extensible scene graph API onto the powerful OpenGL 3D canvas element, supported
                by browsers such as Firefox and Safari.</span></p>
            <p><span>To give you a feel for it, I'm going to show you a <b>really basic</b> scene graph,
            glossing over lots of the inner workings. It hurts me to skip so many of SceneJS more exotic features in this example,
            (like animation, event flows, advanced shaders) but since this is your lunch hour, I'll try to keep this first
                taste short and sweet.</span></p>
        </div>
    </div>
</div>

<!-- content -->
<div id="content">
<div class="row-1">
<div class="wrapper">
<h2>Our first scene graph</h2>
<p>Our first example SceneJS scene graph renders the
    venerable OpenGL teapot to a WebGL canvas element. At its core is a set of vertex and fragment shader
    scripts written in the OpenGL Shader Language (OGSL), while most of the rest of it is
    essentially for loading things like matrices, geometry etc. into variables within
    those scripts.</p>

<p>A key thing to bear in mind when looking over this example is that a scene is traversed in
    depth-first order, during which each node modifies some bit of scene state on pre-visit, then undoes
    its modifications again it on post-visit. Each node therefore only affects those in the subtree beneath it.</p>

<p>At the root of our graph we have, behold, a <b class="class-name">Graph</b> node:</p><br/>

<!--<script src="http://gist.github.com/205819.js"></script>-->
            <pre class="sh_javascript">
var scene = new SceneJs.Graph({
    children: [</pre>
<p> Within that, a <b class="class-name">Canvas</b> node activates a DOM canvas element for its subtree. You can have
    more
    than one Canvas node in your scene if you want multiple views of the scene on multiple canvas tags
    throughout your page
    (alternatively, you could have multiple ViewPorts on the
    same Canvas).
</p>
            <pre class="sh_javascript">
        new SceneJs.Canvas({

            canvasId: 'mycanvas',

            clearColor: new SceneJs.Color(0.8, 0.8, 0.9, 1.0),
            depthTest: true,
            clearDepth: 1.0,

            children: [</pre>
<a name="shader-node"></a><p>We've configured the backend with a ShaderBackend plugin of type "example-shader-1" (<a href="#shader-plugin">shown below</a>), which our
    <b class="class-name">Shader</b> node activates to provide OpenGL Shading Language scripts to the GL engine.
    You can have many Shader nodes in your scene, to activate different shading scripts for different
    subtrees.
</p>
            <pre class="sh_javascript">
                new SceneJs.Shader({

                    type: 'example-shader-1',</pre>
<p>One of our Shader scripts has a light source variable, which we can provide a
    value for here. We could also provide values in ScriptVars nodes anywhere
    within the Shader's subtree.
</p>
            <pre class="sh_javascript">
                    vars: {
                        light: {
                            pos: {
                                x: -100.0,
                                y: -200.0,
                                z: 200.0
                            }
                        }
                    },

                    children: [</pre>
<p>A <b class="class-name">ViewPort</b> node selects the area of the Canvas that sub nodes will affect:</p>
            <pre class="sh_javascript">
                        new SceneJs.Viewport({

                            x : 1,
                            y : 1,
                            width: 500,
                            height: 400,

                            children: [</pre>
<p>Next, a <b class="class-name">Perspective</b> node sets up the perspective transform applied to sub nodes.
    Internally, it generates a perspective matrix and loads it into a special
    projection matrix variable in the Shader scripts.
</p>
            <pre class="sh_javascript">
                                new SceneJs.Perspective({

                                    fovy : 60.0,
                                    aspect : 1.0,
                                    near : 0.1,
                                    far : 400.0,

                                    children: [ </pre>
<p>
    A <b class="class-name">LookAt</b> node sets up the model-view transform to apply to sub nodes
    before the perspective transform.
    Internally, it generates a model-view matrix and loads it into
    a special variable in the Shader scripts.
</p>
            <pre class="sh_javascript">
                                        new SceneJs.LookAt({

                                            eye : { z: -50.0 },
                                            up : { y: 1.0 },

                                            children: [
                                                new SceneJs.Layer({
                                                    renderMethods: {
                                                        cullBackfaces: false
                                                    },
                                                    children: [</pre>
<p> A <b class="class-name">Rotate</b> node concatenates a rotation transform onto
    the model-view matrix and reloads the matrix into
    the Shader scripts:
</p>
            <pre class="sh_javascript">
                                                        new SceneJs.Rotate({

                                                            x: 1.0,
                                                            angle: -45.0,

                                                            children: [

                                                                new SceneJs.Rotate({

                                                                    y: 1.0,
                                                                    angle: 45.0,

                                                                    children: [</pre>
<p> A <b class="class-name">Scale</b> node concatenates a scaling
    transformation onto the model-view
    matrix and reloads the matrix into the
    Shader scripts:
</p>
            <pre class="sh_javascript">
                                                                        new SceneJs.Scale({

                                                                            x: 5.0,
                                                                            y: 5.0,
                                                                            z: 5.0,

                                                                            children: [</pre>
<p> A <b class="class-name">Teapot</b> node is a specialised
    <b class="class-name">Geometry</b> node, which loads
    vertices, normals and faces
    for the venerable OpenGL teapot
    into special variables in
    the Shader scripts:
</p>
            <pre class="sh_javascript">
                                                                                new SceneJs.scene.ux.Teapot()
                                                                            ]
                                                                        }) // SceneJs.Scale
                                                                    ]
                                                                }) // SceneJs.Rotate
                                                            ]
                                                        }) // SceneJs.Rotate
                                                    ]
                                                }) // SceneJs.Layer
                                            ]
                                        }) // SceneJs.LookAt
                                    ]
                                }) // SceneJs.Perspective
                            ]
                        }) // SceneJs.ViewPort
                    ]
                }) // SceneJs.Shader
            ]
        }) // SceneJs.Canvas
    ]
}); // SceneJs.Graph</pre>
<p>To render a single frame of the scene graph, you can now call:
</p>
            <pre class="sh_javascript">
scene.traverse(); </pre>
<br/><br/>
    <a name="shader-plugin"></a><h2>Shader backend plugin</h2>
     <p>To support our scene graph's Shader node (<a href="#shader-node">described earlier</a>), we must prepare SceneJS by plugging in the
         <b class="class-name">ShaderBackend</b> shown below.</p>
<pre class="sh_javascript">
            SceneJs.Backend.installNodeBackend(new SceneJs.ShaderBackend({

                nodeType: 'example-shader-1',
    </pre><p>Its got an OGSL <i>fragment shader</i> script:</p>
         <pre class="sh_javascript">
                fragmentShaders: [
                    'varying float intensity; ' +
                    'varying vec4 FragColor; ' +
                    'void main(void) { ' +
                    '      gl_FragColor = FragColor; ' +
                    '}'
                ],</pre><p>and an OGSL <i>vertex shader</i> script:</p>
         <pre class="sh_javascript">
                vertexShaders: [
                    "attribute vec3 Vertex;\n" +
                    "attribute vec3 Normal;\n" +
                    "attribute vec4 InColor;\n" +

                        /* Matrix locations - these will be mapped to scene reserved names
                         */
                    "uniform mat4 PMatrix;\n" +
                    "uniform mat4 MVMatrix;\n" +
                    "uniform mat3 NMatrix;\n" +

                        /* Light position - a value for this is specified in the node's 'vars' config
                         */
                    "uniform vec4 LightPos;\n" +

                    "varying vec4 FragColor;\n" +

                    "void main(void) {\n" +
                    "    vec4 v = vec4(Vertex, 1.0);\n" +
                    "    vec4 vmv = MVMatrix * v;\n" +
                    "    gl_Position = PMatrix * vmv;\n" +

                    "    vec3 nn = normalize(NMatrix * Normal);\n" +
                    "    vec3 lightDir = vec3(normalize(vmv - LightPos));\n" +

                    "    float intensity = dot(lightDir, nn);\n" +

                    "    vec4 color;\n" +

                    "    if (intensity > 0.95)\n" +
                    "      color = vec4(1.0,0.5,0.5,1.0);\n" +
                    "    else if (intensity > 0.5)\n" +
                    "      color = vec4(0.6,0.3,0.3,1.0);\n" +
                    "    else if (intensity > 0.25)\n" +
                    "      color = vec4(0.4,0.2,0.2,1.0);\n" +
                    "    else\n" +
                    "      color = vec4(0.2,0.1,0.1,1.0);\n" +

                    "    FragColor = color;\n" +
                    "}\n"
                ],
</pre><p>The shader backend works a bit like a bean, in that it has a map of setter
    methods that are used by SceneJS to load the matrices, geometry, colors and light source into the scripts,
    via canvas OpenGL context. Each of these has a name recognised by the scene nodes, and is passed the context, a
callback that it uses to resolve the location of it's target variable(s), and the data to set:</p>
         <pre class="sh_javascript">
                setters : {

                    scenejs_ModelViewMatrix: function(gl, findVar, mat) {
                        gl.uniformMatrix4fv(findVar(gl, 'MVMatrix'), mat.flatten());
                    },

                    scenejs_ModelViewProjectionMatrix: function(gl, findVar, mat) {
                        gl.uniformMatrix4fv(findVar(gl, 'PMatrix'), mat.flatten());
                    },

                    scenejs_NormalMatrix: function(gl, findVar, mat) {
                        gl.uniformMatrix3fv(findVar(gl, 'NMatrix'), mat.flatten());
                    },</pre><p>The setters used by Teapot also encapsulate OpenGL calls to enable their respective
    script arrays (an OGSL thing):</p><pre class="sh_javascript">
                    scenejs_Normal: function(gl, findVar, normals) {
                        var loc = findVar(gl, 'Normal');
                        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, normals);
                        gl.enableVertexAttribArray(loc);
                    },

                    scenejs_Vertex: function(gl, findVar, vertices) {
                        var loc = findVar(gl, 'Vertex') ;
                        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, vertices);
                        gl.enableVertexAttribArray(loc);
                    },

                    scenejs_Color:  function(gl, findVar, colors) {
                        var loc = findVar(gl, 'InColor');
                        gl.vertexAttribPointer(loc, 4, gl.FLOAT, false, 0, colors);
                        gl.enableVertexAttribArray(loc);
                    },

    </pre><p>So far, the setters have had reserved names that SceneJS knows how to find. Finally, here is the light source
    setter method, with a name that maps to the Shader node variable <a href="#shader-node">described earlier</a>. Note
how it translates the light source into a vector, which it loads into to appropriate variable:</p><pre class="sh_javascript">
                    light: function(gl, findVar, light) {
                        gl.uniform4fv(findVar(gl, 'LightPos'), [light.pos.x, light.pos.y, light.pos.z, 1.0]);
                    }
                }
            }));
      </pre>
</div>
</div>
<div id="footer">
    <p>&copy; 2009, <a href="http://www.xeolabs.com">XeoLabs</a></p>

</div>

</div>

</div>

<!--
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10689958-1");
pageTracker._trackPageview();
} catch(err) {}
</script>
-->
</body>

</html>
